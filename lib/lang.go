// Autogenerated by goll1e, a LL(1) parser generator for the Go programming language.
package gohaml

import (
	"container/vector"
	"fmt"
)

type yystype struct {
	c icodenode
	s string
	i interface{}
	n inode
}
var yytable = [3][9]int {
	[9]int{-1,0,1,-1,-1,-1,-1,-1,-1,},
	[9]int{-1,-1,3,-1,-1,-1,-1,2,-1,},
	[9]int{5,-1,-1,-1,-1,-1,-1,-1,4,},
}
var yycharmap = map[int]int {
	',':3,
	'=':5,
	':':4,
	'.':8,
}
const (
	yyMINTOKEN int = 62
	ident = 64
	tfor = 63
	trange = 68
	atom = 69
	yyMAXTOKEN = 72
	yyUSER = 79
)
var yyprods = [6][]int {
	[]int{63,64,44,64,58,61,68,64,},
	[]int{64,58,61,74,},
	[]int{69,},
	[]int{64,75,},
	[]int{46,64,75,},
	[]int{},
}
func yyrunrule(i int, act *yystype, yyres vector.Vector) {
	switch i {
	case 0:
{
															rn := new(rangenode)
															rn._lhs1 = yyres[len(yyres) - 2].(*yystype).s
															rn._lhs2 = yyres[len(yyres) - 4].(*yystype).s
															rn._rhs = res{yyres[len(yyres) - 8].(*yystype).s, true}
															act.n = rn
														}
	case 1:
{
															yyres[len(yyres) - 4].(*yystype).c.setLHS(yyres[len(yyres) - 1].(*yystype).s)
															act.n = yyres[len(yyres) - 4].(*yystype).c
														}
	case 2:
{
															dan := new(declassnode)
															dan._rhs = yyres[len(yyres) - 1].(*yystype).i
															act.c = dan
														}
	case 3:
{
															dan := new(vdeclassnode)
															dan._rhs.value = yyres[len(yyres) - 1].(*yystype).s + yyres[len(yyres) - 2].(*yystype).s
															dan._rhs.needsResolution = true
															act.c = dan			
														}
	case 4:
{ act.s = fmt.Sprintf(".%s%s", yyres[len(yyres) - 2].(*yystype).s, yyres[len(yyres) - 3].(*yystype).s)}
	case 5:
{ act.s = "" }
	}
}
func yytranslate(t int, eof int) int {
	if t == eof {return 0}
	if t >= yyMAXTOKEN {return t - yyMAXTOKEN - 1}
	if t <= yyMINTOKEN {return yycharmap[t]}
	return t - yyMINTOKEN
}
func yyparse(eof int, nextWord func(v *yystype)int) (output bool, result inode) {
	curyys := &yystype{}
	var yyres vector.Vector
	var inputs vector.IntVector
	var values vector.Vector
	word := nextWord(curyys)
	if(word > yyMINTOKEN && word < yyMAXTOKEN) {values.Push(curyys)}
	curyys = &yystype{}
	var stack vector.IntVector
	stack.Push(eof)
	stack.Push(0)
	stack.Push(73)
	tos := stack.Last()
	for true {
		if tos == eof && word == eof {output = true; break}
		if (tos < yyMAXTOKEN) || tos == eof {
			if tos == word {
				inputs.Push(tos)
				stack.Pop()
				stack.Pop()
				word = nextWord(curyys)
				if(word > yyMINTOKEN && word < yyMAXTOKEN) {values.Push(curyys)}
				curyys = &yystype{}
				tos = stack.Last()
			} else {break}
		} else {
			row, col := yytranslate(tos, eof), yytranslate(word, eof)
			ruleNumber := yytable[row][col]
			if ruleNumber == -1 {break /* Inform of error. */}
			inputs.Push(ruleNumber + yyMAXTOKEN)
			stack.Pop()
			stack.Pop()
			for i := len(yyprods[ruleNumber]) - 1;
				i >= 0;
				i-- {
				stack.Push(-1)
				stack.Push(yyprods[ruleNumber][i])
			}
			tos = stack.Last()
		}
	}
	if output {
		for len(inputs) > 0 {
			r := inputs.Pop()
			if r < yyMINTOKEN {
				yyres.Push(nil)
				continue
			}
			if r < yyMAXTOKEN {
				value := values.Pop()
				yyres.Push(value)
				continue
			}
			ruleNumber := r - yyMAXTOKEN
			v := &yystype{}
			yyrunrule(ruleNumber, v, yyres)
			numTokens := len(yyprods[ruleNumber])
			for i := 0; i < numTokens; i++ {
				yyres.Pop()
			}
			yyres.Push(v)
		}
		result = yyres[0].(*yystype).n
	}
	return
}


